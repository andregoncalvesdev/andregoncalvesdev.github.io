<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>André Gonçalves</title>
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicon/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon/favicon-16x16.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      overflow: hidden;
      background: #000;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    }

    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 0;
    }

    .content {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 10;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 28px;
    }

    .profile-photo {
      width: clamp(200px, 35vw, 320px);
      height: auto;
      border-radius: 50%;
      object-fit: cover;
    }

    .info {
      text-align: center;
      color: #fff;
    }

    .name {
      font-size: clamp(1.1rem, 2.5vw, 1.4rem);
      font-weight: 400;
      letter-spacing: 0.15em;
      margin-bottom: 8px;
    }

    .role {
      font-size: clamp(0.8rem, 1.5vw, 0.95rem);
      font-weight: 300;
      letter-spacing: 0.08em;
      opacity: 0.6;
    }
  </style>
</head>
<body>
  <div class="content">
    <img src="/assets/profile.png" alt="André Gonçalves" class="profile-photo">
    <div class="info">
      <div class="name">André Gonçalves</div>
      <div class="role">Code at Uphold</div>
    </div>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';

    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });

    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x000000, 1);
    document.body.appendChild(renderer.domElement);

    // Stars / Galaxy particles
    const starsCount = 3000;
    const starsPositions = new Float32Array(starsCount * 3);
    const starsSizes = new Float32Array(starsCount);

    for (let i = 0; i < starsCount; i++) {
      const i3 = i * 3;
      const radius = Math.random() * 100 + 20;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos((Math.random() * 2) - 1);

      starsPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
      starsPositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
      starsPositions[i3 + 2] = radius * Math.cos(phi) - 50;

      starsSizes[i] = Math.random() * 1.5 + 0.5;
    }

    const starsGeometry = new THREE.BufferGeometry();
    starsGeometry.setAttribute('position', new THREE.BufferAttribute(starsPositions, 3));
    starsGeometry.setAttribute('size', new THREE.BufferAttribute(starsSizes, 1));

    const starsMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uPixelRatio: { value: Math.min(window.devicePixelRatio, 2) },
        uTime: { value: 0 }
      },
      vertexShader: `
        attribute float size;
        uniform float uPixelRatio;
        uniform float uTime;
        varying float vAlpha;

        void main() {
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          gl_Position = projectionMatrix * mvPosition;
          gl_PointSize = size * uPixelRatio * (100.0 / -mvPosition.z);

          // Twinkle effect
          float twinkle = sin(uTime * 2.0 + position.x * 0.5 + position.y * 0.3) * 0.3 + 0.7;
          vAlpha = twinkle * smoothstep(150.0, 20.0, -mvPosition.z);
        }
      `,
      fragmentShader: `
        varying float vAlpha;

        void main() {
          vec2 center = gl_PointCoord - vec2(0.5);
          float dist = length(center);
          if (dist > 0.5) discard;

          float alpha = smoothstep(0.5, 0.0, dist) * vAlpha;
          gl_FragColor = vec4(1.0, 1.0, 1.0, alpha);
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    const stars = new THREE.Points(starsGeometry, starsMaterial);
    scene.add(stars);

    // Subtle blue nebula glow (far background)
    const nebulaGeometry = new THREE.PlaneGeometry(80, 80);
    const nebulaMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float uTime;
        varying vec2 vUv;

        // Simple noise
        float noise(vec2 p) {
          return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
        }

        float smoothNoise(vec2 p) {
          vec2 i = floor(p);
          vec2 f = fract(p);
          f = f * f * (3.0 - 2.0 * f);

          float a = noise(i);
          float b = noise(i + vec2(1.0, 0.0));
          float c = noise(i + vec2(0.0, 1.0));
          float d = noise(i + vec2(1.0, 1.0));

          return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
        }

        float fbm(vec2 p) {
          float value = 0.0;
          float amplitude = 0.5;
          for (int i = 0; i < 4; i++) {
            value += amplitude * smoothNoise(p);
            p *= 2.0;
            amplitude *= 0.5;
          }
          return value;
        }

        void main() {
          vec2 uv = vUv - 0.5;
          float dist = length(uv);

          // Animated noise for morphing effect
          vec2 noiseCoord = uv * 2.0 + uTime * 0.05;
          float n = fbm(noiseCoord);
          float n2 = fbm(noiseCoord * 1.5 - uTime * 0.03);

          // Blue gradient with noise
          float intensity = smoothstep(0.8, 0.0, dist) * 0.15;
          intensity *= (n * 0.5 + n2 * 0.5);

          vec3 color = vec3(0.0, 0.3, 1.0) * intensity;

          gl_FragColor = vec4(color, intensity);
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    const nebula = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
    nebula.position.z = -60;
    scene.add(nebula);

    camera.position.z = 30;

    // Mouse interaction
    const mouse = { x: 0, y: 0 };
    window.addEventListener('mousemove', (e) => {
      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    });

    // Touch support
    window.addEventListener('touchmove', (e) => {
      if (e.touches.length > 0) {
        mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
      }
    });

    // Animation
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);

      const time = clock.getElapsedTime();

      // Update uniforms
      starsMaterial.uniforms.uTime.value = time;
      nebulaMaterial.uniforms.uTime.value = time;

      // Slow rotation
      stars.rotation.y += 0.0001;
      stars.rotation.x += 0.00005;

      // Subtle parallax
      stars.position.x = mouse.x * 2;
      stars.position.y = mouse.y * 1;
      nebula.position.x = mouse.x * 5;
      nebula.position.y = mouse.y * 3;

      renderer.render(scene, camera);
    }

    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      starsMaterial.uniforms.uPixelRatio.value = Math.min(window.devicePixelRatio, 2);
    });

    animate();
  </script>
</body>
</html>
