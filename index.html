<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>André Gonçalves</title>
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicon/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon/favicon-16x16.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      overflow: hidden;
      background: #000;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    }

    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 0;
    }

    .content {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 10;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 24px;
    }

    .profile-photo {
      width: clamp(180px, 30vw, 280px);
      height: auto;
      border-radius: 50%;
      object-fit: cover;
      box-shadow: 0 0 60px rgba(0, 102, 255, 0.3);
    }

    .info {
      text-align: center;
      color: #fff;
    }

    .name {
      font-size: clamp(1rem, 2.5vw, 1.25rem);
      font-weight: 400;
      letter-spacing: 0.1em;
      margin-bottom: 6px;
    }

    .role {
      font-size: clamp(0.75rem, 1.5vw, 0.875rem);
      font-weight: 300;
      letter-spacing: 0.05em;
      opacity: 0.7;
    }
  </style>
</head>
<body>
  <div class="content">
    <img src="/assets/profile.png" alt="André Gonçalves" class="profile-photo">
    <div class="info">
      <div class="name">André Gonçalves</div>
      <div class="role">Code at Uphold</div>
    </div>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';

    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });

    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x000000, 1);
    document.body.appendChild(renderer.domElement);

    // Galaxy particles
    const galaxyCount = 5000;
    const galaxyPositions = new Float32Array(galaxyCount * 3);
    const galaxyColors = new Float32Array(galaxyCount * 3);
    const galaxySizes = new Float32Array(galaxyCount);

    for (let i = 0; i < galaxyCount; i++) {
      const i3 = i * 3;
      const radius = Math.random() * 15 + 2;
      const angle = Math.random() * Math.PI * 2;
      const spiral = (Math.random() - 0.5) * 2;

      galaxyPositions[i3] = Math.cos(angle) * radius + (Math.random() - 0.5) * 2;
      galaxyPositions[i3 + 1] = (Math.random() - 0.5) * 8;
      galaxyPositions[i3 + 2] = Math.sin(angle) * radius + (Math.random() - 0.5) * 2 - 10;

      // Color variation (white to light blue)
      const colorMix = Math.random();
      galaxyColors[i3] = 0.8 + colorMix * 0.2;
      galaxyColors[i3 + 1] = 0.85 + colorMix * 0.15;
      galaxyColors[i3 + 2] = 1.0;

      galaxySizes[i] = Math.random() * 2 + 0.5;
    }

    const galaxyGeometry = new THREE.BufferGeometry();
    galaxyGeometry.setAttribute('position', new THREE.BufferAttribute(galaxyPositions, 3));
    galaxyGeometry.setAttribute('color', new THREE.BufferAttribute(galaxyColors, 3));
    galaxyGeometry.setAttribute('size', new THREE.BufferAttribute(galaxySizes, 1));

    const galaxyMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 },
        uPixelRatio: { value: Math.min(window.devicePixelRatio, 2) }
      },
      vertexShader: `
        attribute float size;
        attribute vec3 color;
        varying vec3 vColor;
        varying float vAlpha;
        uniform float uPixelRatio;

        void main() {
          vColor = color;
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          gl_Position = projectionMatrix * mvPosition;
          gl_PointSize = size * uPixelRatio * (200.0 / -mvPosition.z);
          vAlpha = smoothstep(20.0, 5.0, -mvPosition.z);
        }
      `,
      fragmentShader: `
        varying vec3 vColor;
        varying float vAlpha;

        void main() {
          vec2 center = gl_PointCoord - vec2(0.5);
          float dist = length(center);
          if (dist > 0.5) discard;
          float alpha = smoothstep(0.5, 0.0, dist) * vAlpha * 0.8;
          gl_FragColor = vec4(vColor, alpha);
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      vertexColors: true
    });

    const galaxy = new THREE.Points(galaxyGeometry, galaxyMaterial);
    scene.add(galaxy);

    // Morphing blue cloud using multiple overlapping spheres with noise
    const cloudGroup = new THREE.Group();

    const cloudMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 },
        uColor: { value: new THREE.Color(0x0055ff) }
      },
      vertexShader: `
        uniform float uTime;
        varying vec3 vNormal;
        varying float vDisplacement;

        // Simplex noise function
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

        float snoise(vec3 v) {
          const vec2 C = vec2(1.0/6.0, 1.0/3.0);
          const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
          vec3 i  = floor(v + dot(v, C.yyy));
          vec3 x0 = v - i + dot(i, C.xxx);
          vec3 g = step(x0.yzx, x0.xyz);
          vec3 l = 1.0 - g;
          vec3 i1 = min(g.xyz, l.zxy);
          vec3 i2 = max(g.xyz, l.zxy);
          vec3 x1 = x0 - i1 + C.xxx;
          vec3 x2 = x0 - i2 + C.yyy;
          vec3 x3 = x0 - D.yyy;
          i = mod289(i);
          vec4 p = permute(permute(permute(
            i.z + vec4(0.0, i1.z, i2.z, 1.0))
            + i.y + vec4(0.0, i1.y, i2.y, 1.0))
            + i.x + vec4(0.0, i1.x, i2.x, 1.0));
          float n_ = 0.142857142857;
          vec3 ns = n_ * D.wyz - D.xzx;
          vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
          vec4 x_ = floor(j * ns.z);
          vec4 y_ = floor(j - 7.0 * x_);
          vec4 x = x_ *ns.x + ns.yyyy;
          vec4 y = y_ *ns.x + ns.yyyy;
          vec4 h = 1.0 - abs(x) - abs(y);
          vec4 b0 = vec4(x.xy, y.xy);
          vec4 b1 = vec4(x.zw, y.zw);
          vec4 s0 = floor(b0)*2.0 + 1.0;
          vec4 s1 = floor(b1)*2.0 + 1.0;
          vec4 sh = -step(h, vec4(0.0));
          vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
          vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
          vec3 p0 = vec3(a0.xy, h.x);
          vec3 p1 = vec3(a0.zw, h.y);
          vec3 p2 = vec3(a1.xy, h.z);
          vec3 p3 = vec3(a1.zw, h.w);
          vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
          p0 *= norm.x;
          p1 *= norm.y;
          p2 *= norm.z;
          p3 *= norm.w;
          vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
          m = m * m;
          return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
        }

        void main() {
          vNormal = normal;

          float noise = snoise(position * 0.8 + uTime * 0.15);
          float noise2 = snoise(position * 1.5 - uTime * 0.1);
          float displacement = noise * 0.4 + noise2 * 0.2;
          vDisplacement = displacement;

          vec3 newPosition = position + normal * displacement;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
        }
      `,
      fragmentShader: `
        uniform vec3 uColor;
        uniform float uTime;
        varying vec3 vNormal;
        varying float vDisplacement;

        void main() {
          float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 2.0);
          float intensity = fresnel * 0.6 + 0.2;
          intensity += vDisplacement * 0.3;

          vec3 color = uColor * intensity;
          float alpha = fresnel * 0.4 + 0.1;

          gl_FragColor = vec4(color, alpha);
        }
      `,
      transparent: true,
      side: THREE.DoubleSide,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    // Create multiple cloud layers
    const cloudGeometry = new THREE.IcosahedronGeometry(3, 4);
    const cloud1 = new THREE.Mesh(cloudGeometry, cloudMaterial);
    cloud1.position.z = -5;
    cloudGroup.add(cloud1);

    const cloud2Geometry = new THREE.IcosahedronGeometry(2.5, 4);
    const cloud2Material = cloudMaterial.clone();
    cloud2Material.uniforms.uColor.value = new THREE.Color(0x0088ff);
    const cloud2 = new THREE.Mesh(cloud2Geometry, cloud2Material);
    cloud2.position.set(1, 0.5, -6);
    cloudGroup.add(cloud2);

    const cloud3Geometry = new THREE.IcosahedronGeometry(2, 4);
    const cloud3Material = cloudMaterial.clone();
    cloud3Material.uniforms.uColor.value = new THREE.Color(0x0044cc);
    const cloud3 = new THREE.Mesh(cloud3Geometry, cloud3Material);
    cloud3.position.set(-1, -0.5, -4);
    cloudGroup.add(cloud3);

    scene.add(cloudGroup);

    camera.position.z = 5;

    // Mouse interaction
    const mouse = { x: 0, y: 0 };
    window.addEventListener('mousemove', (e) => {
      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    });

    // Animation
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);

      const time = clock.getElapsedTime();

      // Update galaxy
      galaxyMaterial.uniforms.uTime.value = time;
      galaxy.rotation.y += 0.0002;
      galaxy.rotation.x = Math.sin(time * 0.1) * 0.1;

      // Update clouds
      cloudGroup.children.forEach((cloud, i) => {
        cloud.material.uniforms.uTime.value = time + i * 2;
        cloud.rotation.x = time * 0.05 + i;
        cloud.rotation.y = time * 0.08 + i;
      });

      // Subtle parallax
      cloudGroup.position.x = mouse.x * 0.3;
      cloudGroup.position.y = mouse.y * 0.2;
      galaxy.position.x = mouse.x * 0.1;
      galaxy.position.y = mouse.y * 0.1;

      renderer.render(scene, camera);
    }

    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      galaxyMaterial.uniforms.uPixelRatio.value = Math.min(window.devicePixelRatio, 2);
    });

    animate();
  </script>
</body>
</html>
